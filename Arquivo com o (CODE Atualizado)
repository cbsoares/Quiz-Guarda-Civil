// Code.gs — API JSON para o Quiz (cole inteiro, substitua seu Code.gs atual)

// ===== CONFIG =====
const SPREADSHEET_ID = '18eyeKiRJpSYDOWIqc4SVvKJ51Ozn7mWGzMQtU1H1f4I'; // <- seu ID da planilha
const SHEET_NAME = 'Questões GSM';
const STUDY_SHEET_NAME = 'Estudos';
const QUIZ_SIZE = 20;
const QUESTION_TIME_MS = 0;

// ===== util =====
function _normalize(s){
  if (s === null || s === undefined) return "";
  return s.toString().trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
}

// Lê planilha usando openById (standalone web app precisa do ID)
function _readQuestionsSheet(){
  if (!SPREADSHEET_ID) throw new Error("SPREADSHEET_ID não definido em Code.gs");
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  if (!ss) throw new Error("Não foi possível abrir a planilha (verifique SPREADSHEET_ID e permissões).");
  const sheet = ss.getSheetByName(SHEET_NAME);
  if (!sheet) throw new Error("Aba '"+SHEET_NAME+"' não encontrada.");
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow < 2) return { headers: [], rows: [] };
  const all = sheet.getRange(1,1,lastRow,lastCol).getValues();
  const headers = all[0].map(h => (h===null? '': h.toString()));
  const rows = all.slice(1);
  return { headers, rows };
}

// Lê qualquer aba pelo nome (genérico)
function _readSheetByName(sheetName){
  if (!SPREADSHEET_ID) throw new Error("SPREADSHEET_ID não definido em Code.gs");
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  if (!ss) throw new Error("Não foi possível abrir a planilha (verifique SPREADSHEET_ID e permissões).");
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) throw new Error("Aba '"+sheetName+"' não encontrada.");
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow < 1) return { headers: [], rows: [] };
  const all = sheet.getRange(1,1,lastRow,lastCol).getValues();
  const headers = all[0].map(h => (h===null? '': h.toString()));
  const rows = all.slice(1);
  return { headers, rows };
}

function _mapHeaderIndexes(headers){
  const normToIndex = {};
  for (let i=0;i<headers.length;i++) normToIndex[_normalize(headers[i])] = i;
  const findIndex = (cands) => {
    for (const c of cands){
      const k = _normalize(c);
      if (k in normToIndex) return normToIndex[k];
    }
    return -1;
  };
  return {
    idxID: findIndex(['id','identificador']),
    idxPerg: findIndex(['pergunta','perguntas','questao','questão','enunciado','pergunta?','perg']),
    idxA: findIndex(['a','alternativa a','alt a','opcao a','opção a','a)']),
    idxB: findIndex(['b','alternativa b','alt b','opcao b','opção b','b)']),
    idxC: findIndex(['c','alternativa c','alt c','opcao c','opção c','c)']),
    idxD: findIndex(['d','alternativa d','alt d','opcao d','opção d','d)']),
    idxResp: findIndex(['resposta','respostas','correta','gabarito','resposta correta','resposta?']),
    idxExp: findIndex(['explicacao','explicação','explicaçao','explic','observacao','comentario','comentário']),
    idxMat: findIndex(['materia','matéria','assunto','topico','tópico','categoria'])
  };
}

function _rowsToQuestions(headers, rows){
  const idx = _mapHeaderIndexes(headers);
  // validação mínima
  if ([idx.idxPerg, idx.idxA, idx.idxB, idx.idxC, idx.idxD, idx.idxResp, idx.idxExp].some(x => x === -1)){
    throw new Error("Cabeçalhos obrigatórios não encontrados. Verifique primeira linha da aba '"+SHEET_NAME+"' (Pergunta,A,B,C,D,Resposta,Explicação).");
  }
  const out = [];
  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    const pergunta = (r[idx.idxPerg] || '').toString().trim();
    if (!pergunta) continue;
    const idVal = idx.idxID !== -1 ? r[idx.idxID] : (i+1);
    const answerRaw = (r[idx.idxResp] || '').toString().trim().toUpperCase();
    const answerLetter = answerRaw ? answerRaw.substr(0,1) : '';
    out.push({
      id: idVal,
      materia: idx.idxMat !== -1 ? (r[idx.idxMat] || '').toString() : '',
      question: pergunta,
      A: (r[idx.idxA] || '').toString(),
      B: (r[idx.idxB] || '').toString(),
      C: (r[idx.idxC] || '').toString(),
      D: (r[idx.idxD] || '').toString(),
      answer: answerLetter,
      explanation: (r[idx.idxExp] || '').toString()
    });
  }
  return out;
}

// Converte uma aba de "cartões" (pergunta / resposta) em objetos
function _rowsToCards(headers, rows){
  const normHeaders = headers.map(h=>_normalize(h));
  // procura índices
  const idxPerg = normHeaders.indexOf('pergunta') !== -1 ? normHeaders.indexOf('pergunta') :
                  (normHeaders.indexOf('perguntas') !== -1 ? normHeaders.indexOf('perguntas') :
                  (normHeaders.indexOf('question') !== -1 ? normHeaders.indexOf('question') : -1));
  const idxResp = normHeaders.indexOf('resposta') !== -1 ? normHeaders.indexOf('resposta') :
                  (normHeaders.indexOf('respostas') !== -1 ? normHeaders.indexOf('respostas') :
                  (normHeaders.indexOf('answer') !== -1 ? normHeaders.indexOf('answer') : -1));
  const idxTop = normHeaders.indexOf('topico') !== -1 ? normHeaders.indexOf('topico') :
                 (normHeaders.indexOf('tópico') !== -1 ? normHeaders.indexOf('tópico') :
                 (normHeaders.indexOf('materia') !== -1 ? normHeaders.indexOf('materia') :
                 (normHeaders.indexOf('assunto') !== -1 ? normHeaders.indexOf('assunto') : -1)));
  const out = [];
  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    const pergunta = (idxPerg !== -1 ? (r[idxPerg] || '') : (r[0] || '')).toString().trim();
    const resposta = (idxResp !== -1 ? (r[idxResp] || '') : (r[1] || '')).toString().trim();
    const topico = (idxTop !== -1 ? (r[idxTop] || '') : '').toString().trim();
    if (!pergunta && !resposta) continue;
    out.push({
      id: i+1,
      pergunta: pergunta,
      resposta: resposta,
      topico: topico
    });
  }
  return out;
}

// ===== API functions =====
function getAllQuestions(shuffle = false){
  const { headers, rows } = _readQuestionsSheet();
  const qs = _rowsToQuestions(headers, rows);
  if (shuffle){
    for (let i = qs.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [qs[i], qs[j]] = [qs[j], qs[i]];
    }
  }
  return qs;
}

function getTopics(){
  const { headers, rows } = _readQuestionsSheet();
  const qs = _rowsToQuestions(headers, rows);
  const seen = new Set();
  const out = [];
  for (const q of qs){
    const t = (q.materia || 'Geral').toString().trim() || 'Geral';
    if (!seen.has(t)){
      seen.add(t);
      out.push(t);
    }
  }
  return out;
}

function getQuestionsByTopic(topic){
  const tnorm = (topic || '').toString().trim();
  const all = getAllQuestions(true);
  const subset = (!tnorm || tnorm.toLowerCase() === 'todos') ? all : all.filter(q => (q.materia || '').toString().trim() === tnorm);
  return subset.slice(0, Math.min(QUIZ_SIZE, subset.length));
}

function getQuestions(){
  return getQuestionsByTopic('Todos');
}

function getStudies(){
  if (!SPREADSHEET_ID) return [];
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(STUDY_SHEET_NAME);
  if (!sheet) return [];
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow < 2) return [];
  const all = sheet.getRange(1,1,lastRow,lastCol).getValues();
  const headers = all[0].map(h => (h===null? '': h.toString().toLowerCase()));
  const idxTopico = headers.indexOf('tópico') !== -1 ? headers.indexOf('tópico') : (headers.indexOf('topico') !== -1 ? headers.indexOf('topico') : 0);
  const idxConteudo = headers.indexOf('conteúdo') !== -1 ? headers.indexOf('conteúdo') : (headers.indexOf('conteudo') !== -1 ? headers.indexOf('conteudo') : 1);
  const rows = all.slice(1);
  const res = [];
  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    const topico = (r[idxTopico] || '').toString();
    const conteudo = (r[idxConteudo] || '').toString();
    if (!topico && !conteudo) continue;
    res.push({topico: topico, conteudo: conteudo});
  }
  return res;
}

// NOVAS FUNÇÕES: ler qualquer aba e retornar cartões / perguntas
function getCards(sheetName){
  try {
    const name = sheetName ? sheetName.toString() : 'cartões';
    const { headers, rows } = _readSheetByName(name);
    const cards = _rowsToCards(headers, rows);
    return cards;
  } catch (err){
    // se não achou a aba, lança erro para o caller tratar
    throw new Error('getCards error: ' + err.toString());
  }
}

function getQuestionsBySheet(sheetName){
  try {
    const name = sheetName ? sheetName.toString() : SHEET_NAME;
    const { headers, rows } = _readSheetByName(name);
    // tenta interpretar como sheet de questões (A/B/C/D)
    try {
      const qs = _rowsToQuestions(headers, rows);
      return qs.slice(0, Math.min(QUIZ_SIZE, qs.length));
    } catch (innerErr){
      // não é uma sheet com colunas A/B/C/D — tenta converter como cards (pergunta/resposta)
      const cards = _rowsToCards(headers, rows);
      // map para formato de questão simples (sem alternativas)
      const mapped = cards.map((c, i) => ({
        id: c.id || i+1,
        materia: c.topico || '',
        question: c.pergunta || c.question || '',
        A: '',
        B: '',
        C: '',
        D: '',
        answer: (c.resposta || '').toString(),
        explanation: ''
      }));
      return mapped.slice(0, Math.min(QUIZ_SIZE, mapped.length));
    }
  } catch (err){
    throw new Error('getQuestionsBySheet error: ' + err.toString());
  }
}

function getSheetByName(sheetName){
  try {
    const name = sheetName ? sheetName.toString() : '';
    if (!name) throw new Error('sheetName obrigatório');
    const { headers, rows } = _readSheetByName(name);
    return { headers: headers, rows: rows };
  } catch (err){
    throw new Error('getSheetByName error: ' + err.toString());
  }
}

// ===== debug helper (execute no editor para forçar autorização e testar) =====
function testReadSheetDebug(){
  try {
    console.log('=== Iniciando diagnóstico ===');
    console.log('SPREADSHEET_ID:', SPREADSHEET_ID);
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    console.log('Spreadsheet name (openById):', ss.getName());
    const sheets = ss.getSheets().map(s=>s.getName()).join(' | ');
    console.log('Sheets:', sheets);
    const { headers, rows } = _readQuestionsSheet();
    console.log('Linhas encontradas:', rows.length);
    console.log('Colunas:', headers.length);
    console.log('Cabeçalhos:', JSON.stringify(headers));
    console.log('=== Diagnóstico finalizado ===');
    return { ok:true, info: 'debug executed' };
  } catch(err){
    console.error('❌ Erro ao testar leitura:', err.toString());
    return { ok:false, error: err.toString() };
  }
}

// ===== doGet para servir como API JSON (e opcionalmente o Index.html) =====
function doGet(e){
  const params = e && e.parameter ? e.parameter : {};
  const action = params.action || '';
  try {
    if (action){
      if (action === 'getTopics') {
        return ContentService.createTextOutput(JSON.stringify({ ok:true, topics: getTopics() })).setMimeType(ContentService.MimeType.JSON);
      }
      if (action === 'getAllQuestions') {
        return ContentService.createTextOutput(JSON.stringify({ ok:true, questions: getAllQuestions(true) })).setMimeType(ContentService.MimeType.JSON);
      }
      if (action === 'getQuestionsByTopic') {
        const topic = params.topic || 'Todos';
        return ContentService.createTextOutput(JSON.stringify({ ok:true, questions: getQuestionsByTopic(topic) })).setMimeType(ContentService.MimeType.JSON);
      }
      if (action === 'getStudies') {
        return ContentService.createTextOutput(JSON.stringify({ ok:true, studies: getStudies() })).setMimeType(ContentService.MimeType.JSON);
      }
      // NOVOS endpoints adicionados para compatibilidade com index.html atualizado
      if (action === 'getCards') {
        const sheet = params.sheet || 'cartões';
        try {
          const cards = getCards(sheet);
          return ContentService.createTextOutput(JSON.stringify({ ok:true, cards: cards })).setMimeType(ContentService.MimeType.JSON);
        } catch(err){
          return ContentService.createTextOutput(JSON.stringify({ ok:false, error: err.toString() })).setMimeType(ContentService.MimeType.JSON);
        }
      }
      if (action === 'getQuestionsBySheet') {
        const sheet = params.sheet || SHEET_NAME;
        try {
          const questions = getQuestionsBySheet(sheet);
          return ContentService.createTextOutput(JSON.stringify({ ok:true, questions: questions })).setMimeType(ContentService.MimeType.JSON);
        } catch(err){
          return ContentService.createTextOutput(JSON.stringify({ ok:false, error: err.toString() })).setMimeType(ContentService.MimeType.JSON);
        }
      }
      if (action === 'getSheetByName' || action === 'getSheet') {
        const sheet = params.sheet;
        if (!sheet) return ContentService.createTextOutput(JSON.stringify({ ok:false, error: 'sheet parameter required' })).setMimeType(ContentService.MimeType.JSON);
        try {
          const sheetData = getSheetByName(sheet);
          return ContentService.createTextOutput(JSON.stringify({ ok:true, sheet: sheetData })).setMimeType(ContentService.MimeType.JSON);
        } catch(err){
          return ContentService.createTextOutput(JSON.stringify({ ok:false, error: err.toString() })).setMimeType(ContentService.MimeType.JSON);
        }
      }
      if (action === 'info') {
        return ContentService.createTextOutput(JSON.stringify({
          ok:true, 
          info: 'Quiz API - actions: getTopics, getQuestionsByTopic, getAllQuestions, getStudies, getCards, getQuestionsBySheet, getSheetByName'
        })).setMimeType(ContentService.MimeType.JSON);
      }
      return ContentService.createTextOutput(JSON.stringify({ ok:false, error:'Unknown action' })).setMimeType(ContentService.MimeType.JSON);
    }
    // sem action: se quiser usar Apps Script como front, devolve o template Index (opcional)
    const t = HtmlService.createTemplateFromFile('Index');
    t.questions = getQuestions();
    t.studies = getStudies();
    t.quizSize = QUIZ_SIZE;
    t.questionTime = QUESTION_TIME_MS;
    return t.evaluate().setTitle('Quiz Guarda Civil').setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  } catch(err){
    return ContentService.createTextOutput(JSON.stringify({ ok:false, error: err.toString() })).setMimeType(ContentService.MimeType.JSON);
  }
}
